Calling ```fork()``` once creates a child process which essentially creates a separate memory space. At the time of fork(), both processes have the same content. Every call leads to an increase in the memory that is occupied. In a practical situation, our computer has limited main memory. Hence creating a process everytime leads to a lot of overhead, thus causing the ```fork()``` call to fail.

In most operating systems, there is a limit on the number of processes that can run on a pc. This can be checked using the command : ```ulimit -u```

In our case, an output of ```24000``` was obtained. This depends on a variety of factors with the available RAM being one of them. 

On testing the code with larger number of rows and columns, the fork() call failed when it was called from the parent for the 16250th time (on an average). Since we are creating as many processes as ```r1 * c2```, we obtain a bound on the product. Interestingly, the number of allowed processes are lower than the total number of fork() calls that are actually made. This is because there are other processes that are present at the same time.

Apart from this the concurrency was also measured using a counter variable to see how many processes actually execute concurrently. For small values of ```r1 * c2```
(i.e. for r1 * c2 < 100) there was a maximum of 1 child running at a time. However for larger values (i.e. for r1 * c2 > 100 * 100) we obtained a maximum of 8 children executing in a concurrent manner. These statistics represent the degree of multiprogramming and also depend on the number of cores that are available to us.     

The maximum speedup would be equal to the number of cores, however in practical cases this would be less than the number of cores since there are many other processes running in the system.
EAGAIN
fork() cannot allocate sufficient memory to copy the parent's page tables and allocate a task structure for the child.
EAGAIN
It was not possible to create a new process because the caller's RLIMIT_NPROC resource limit was encountered. To exceed this limit, the process must have either the CAP_SYS_ADMIN or the CAP_SYS_RESOURCE capability.

EAGAIN A system-imposed limit on the number of threads was encountered.  There are a number of limits that may trigger this error:

the  RLIMIT_NPROC  soft resource limit (set via setrlimit(2)), which limits the number of processes and threads for a real user ID,
                 was reached;

              *  the kernel's system-wide limit on the number of processes and threads, /proc/sys/kernel/threads-max, was reached (see proc(5));

              *  the maximum number of PIDs, /proc/sys/kernel/pid_max, was reached (see proc(5)); or

              *  the PID limit (pids.max) imposed by the cgroup "process number" (PIDs) controller was reached.
ENOMEM
fork() failed to allocate the necessary kernel structures because memory is tight.
number of threads = total virtual memory / (stack size*1024*1024)