#include <iostream>
#include <bitset>
#include <set>

#include <random>
#include <ctime>

#include <sys/types.h>
#include <sys/unistd.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/shm.h>

using namespace std;

const int SIZE = 8;
const int N = 4;
const int resultantMatrixProducer = -10;
set<int> matrixId;



// bitset function

void custom_set(uint8_t &bitset)
{
    bitset = 255;
    return;
}

size_t custom_find_first_one(uint8_t bitset)
{
    size_t i;
    uint8_t one = 1;
    for(i = 0; i < 8; ++i)
    {
        if( (one<<i) & bitset)
        {
            break;
        }
    }
    return i;
}

void custom_flip(uint8_t &bitset, int flip)
{
    if(flip <0 || flip > 7 ) 
        return;
    uint8_t one = 1;
    bitset = bitset ^ (one << flip);
    return ;
}


// generated by a producer and put into the job queue
struct job {
    int producerNumber;
    uint8_t status;
    int matrix[N][N];   // -9 <= matrix[i][j] <= 9
    int matrixId;       // rand(1...1e5)
    int resultIdx;      // where the resultant matrix is stored
};

void printJob(job* J) {
    cout<< "producer Number "<< J->producerNumber<<"\n";
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++)
            cout << J->matrix[i][j] << " ";
        cout << '\n'; 
    }
}

void initJob(job* J, int _producerNumber = -1, int _matrixId = -1, int seed = 0, bool zero = false) {
    J->producerNumber = _producerNumber;
    J->matrixId = _matrixId;
    srand(seed);
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++) {
            J->matrix[i][j] = (zero) ? 0 : (rand()%19 - 9);
        }
    }
    J->resultIdx = -1;
    // all ones , that means all of them needs to be completed       
    custom_set(J->status);
    return;
    // status.flip();
}

struct jobQueue
{
    job jobs[SIZE];
    int producerPtr, workerPtr; // tail, head
    int size; // job created
    int jobCreated;
    int totalJobs;
    int jobsDone;
    int mutex;    
};

int getrandId() {
    int ans = -1;
    do {
        ans = rand()%100000 + 1;
    } while(matrixId.count(ans));
    matrixId.insert(ans);
    return ans;
}

void jobQueueInit(int _totalJobs, jobQueue* Q) {
    // mutex lock
    Q->producerPtr = Q->workerPtr = 0;
    Q->jobCreated = Q->size = 0;
    Q->totalJobs = 0;
    Q->size = 0;
    Q->jobsDone = 0;
    Q->totalJobs = _totalJobs;
    Q->mutex = 0;
    // mutex lock
}

inline bool isJobFinished(jobQueue* Q) {
    cout<<"Total jobs : "<<Q->totalJobs<<"\n";
    cout<<"jobsDone : "<<Q->jobsDone<<"\n";
    return (Q->jobsDone >= Q->totalJobs - 1) && (Q->size == 1);
}

inline bool isJobCreated(jobQueue* Q) {
    cout<<"Total jobs : "<<Q->totalJobs<<"\n";
    cout<<"jobs Created : "<<Q->jobCreated<<"\n";
    return (Q->jobCreated >= Q->totalJobs);
}

bool createJob(jobQueue* Q, int _producerNumber, int seed = 0, bool zero = false) {
    if(isJobCreated(Q))
    {
        return true;
    }
    if(Q->size + 2 >= SIZE) {
        // size + 1 == SIZE
        return false;
    }
    initJob(&(Q->jobs[Q->producerPtr]),_producerNumber, getrandId(), seed, zero);
    printJob(&Q->jobs[Q->producerPtr]);
    Q->producerPtr = (Q->producerPtr + 1)%SIZE;
    (Q->jobCreated)++;
    (Q->size)++;
    return true;
}

bool completeJob(jobQueue* Q) {
    cout<<"CUr Size : "<<Q->size<<endl;
    if(Q->size < 2)
        return false;
    
    // Mem access : mutex lock
    int workerPtr = Q->workerPtr;
    int producerPtr = Q->producerPtr;
    job &curJob = Q->jobs[workerPtr];
    job &nextJob = Q->jobs[(workerPtr + 1)%SIZE];
    // Mutex unlock
    
    if(curJob.resultIdx == -1) {
        if(Q->size == SIZE)
            return false;
        curJob.resultIdx = Q->jobs[workerPtr].resultIdx = Q->jobs[(workerPtr + 1)%SIZE].resultIdx = producerPtr;
        initJob(&(Q->jobs[producerPtr]), resultantMatrixProducer, getrandId(), 0, true); 
        producerPtr = (producerPtr + 1)%SIZE;
        // C S
        // (Q->jobsDone)++;
        (Q->size)++;
    }

    int resIdx = curJob.resultIdx;
    job &resJob = Q->jobs[resIdx];
        
    size_t firstOn = custom_find_first_one(curJob.status);
    
    for(int i = 0; i < SIZE; i++) {
        if((curJob.status >> i)&1) {
            firstOn = i;
            break;
        }
    }
    cout << firstOn << '\n';
    if(firstOn == SIZE)
    {
        cout<<"All jobs are occupied\n";
        return false;
    }
    ///
    int i = firstOn & 1, j = (firstOn >> 1)&1 , k = (firstOn>>2) & 1;
    cout<<"i,j,k "<<i<<", "<<j<<", "<<k<<endl;
    custom_flip(curJob.status, firstOn);
    custom_flip(nextJob.status, firstOn);
    // Compute D (i, j, k) = A(i, k) * B(k, j)

    int row1 = (N / 2)*i + (N / 2);
    int col2 = (N / 2)*j + (N / 2);
    int col1 = (N / 2)*k + (N / 2);
    
    for(int row = (N / 2)*i; row < row1; row++) {
        for(int col = (N / 2)*j; col < col2; col++) {
            // resJob.matrix[row][col] = 0;
            for(int cur = (N / 2)*k; cur < col1; cur++) {
                // mutex
                resJob.matrix[row][col] += curJob.matrix[row][cur] * nextJob.matrix[cur][col];  
            }
            cout<< resJob.matrix[row][col] <<" ";
        }
            cout<<"\n";
    }
    cout<<"**************************first ON " << firstOn<<endl;
    // custom_flip(curJob.status, firstOn);
    // custom_flip(nextJob.status, firstOn);

    if(curJob.status == 0) {
        // all done
        Q->size -= 2;
        (Q->jobsDone)++;
        cout<<"Job Done worked id :"<<Q->workerPtr<< ", worker 2: "<< Q->workerPtr + 1 << "\n";
        printJob(&Q->jobs[resIdx]);
        initJob(&Q->jobs[workerPtr]);
        initJob(&Q->jobs[(workerPtr+1)%SIZE]);
        Q->workerPtr = (Q->workerPtr + 2)%SIZE;
    }
    return true;
}
/////////////////////////////
void producer(int producerId, jobQueue *Q) {
    // if queue not full and jobs fully not created
    // create a job and push into q
    
    // Producer: 
    // 1. generate random job
    // 2. Wait for 0-3 s
    // 3. Try to insert in queue
    //      Wait until queue is full : 
    //      Print job details
    //      Increase job_counter

    while(!isJobCreated(Q)) {
        // mutex lock
        
        int waitTime = rand()%4;
        sleep(waitTime);
        if(Q->mutex != 0)
            continue;
        Q->mutex = 1;
        if(createJob(Q, producerId, producerId)) {
            cout << producerId << "(producer) successfully created job! : )\n";
        } else {
            cout << producerId << "(producer) couldnt create job.. trying again\n"; 
        }
        Q->mutex = 0;
        // mutex unlock
    }
    return;
}

void worker(int workerId, jobQueue *Q) {
    // wait: if q is full or empty ? o
    // wait if 1 matrix only and all jobs done?
    
    // Worker:
    // 1. Wait for 0-3 s
    // 2. Retrieve 2 blocks of the first 2 matrices

    while(!isJobFinished(Q)) {
        // mutex
        
        int waitTime = rand()%4;
        sleep(waitTime);
        if(Q->mutex != 0)
            continue;
        Q->mutex = 1;
        if(completeJob(Q)) {
            cout << workerId << "(worker) successfully completed job! : )\n";
        } else {
            cout << workerId << "(worker)  couldnt complete job.. trying again\n"; 
        }
        Q->mutex = 0;
    }
    return ;
}

int main(int argc, char *argv[]) {
    // Create nP, nW processes
    int nP, nW;
    nP = 2, nW = 2;
    // cin >> nP >> nW;
    int nMatrices;
    nMatrices = 2;
    // cin >> nMatrices;

    // SHM queue https://2k8618.blogspot.com/2011/02/matrix-multiplication-using-shared.html
    // SHM job_created

    // https://pubs.opengroup.org/onlinepubs/007908775/xsh/pthread_mutexattr_setpshared.html


    // Create (SHM) shared memory: shared among all
    // 1. queue: finite size (SIZE)
    // 2. job_created counter : no of matrices gen
    key_t shmkey = 154;
    int shmid1 = shmget(shmkey,sizeof(jobQueue),0666|IPC_CREAT);
    jobQueue *sharedJobQ;
    sharedJobQ = (jobQueue*) shmat(shmid1, NULL, 0);
    
    jobQueueInit(nMatrices, sharedJobQ);
    // shared
    for(int i = 0; i < nP ; i++) {
        int fork_status = fork();
        if(fork_status == 0) {
            cout<< "Producer "<<i<<" created\n";
            producer(i, sharedJobQ);
            cout<< "Producer "<<i<<" exited\n";
            shmdt((void *)sharedJobQ);
            exit(0);            
        }
    }
    
    for(int i = 0; i < nW; i++) {
        int fork_status = fork();
        if(fork_status == 0) {
            cout<< "Worker "<<i<<" created\n";
            worker(i, sharedJobQ);
            cout<< "Worker "<<i<<" exited\n";
            shmdt((void *)sharedJobQ);
            exit(0);
        }
    }
    // check this : wait until 1 matrix and all jobs completed?
    while(wait(NULL) > 0);
 
    shmdt((void *)sharedJobQ);
    shmctl(shmid1, IPC_RMID, NULL);
    return 0;
}