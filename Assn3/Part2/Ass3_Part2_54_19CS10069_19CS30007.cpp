#include <iostream>
#include <bitset>
#include <random>
#include <sys/types.h>
#include <sys/unistd.h>
#include <sys/wait.h>

using namespace std;

const int SIZE = 8;
const int N = 1000;

// generated by a producer and put into the job queue
struct job {
    int producerNumber;
    bitset<8> status;
    int matrix[N][N];   // -9 <= matrix[i][j] <= 9
    int matrixId;   // rand(1...1e5)

    job(int _producerNumber, int _matrixId, int seed = 0, bool zero = false) {
        producerNumber = _producerNumber;
        matrixId = _matrixId;
        srand(seed);
        for(int i = 0; i < N; i++) {
            for(int j = 0; j < N; j++) {
                matrix[i][j] = (zero) ? 0 : (rand()%19 - 9);
            }
        }
        status = 0;        
        // status.all();
        // status.flip();
    }
};


void producer(int producerId) {
    // if queue not full and jobs fully not created
    // create a job and push into q
    while(1) {
        
    }
}

void worker(int workerId) {
    // wait: if q is full or empty ? or all 8 blocks are already taken
    // wait if 1 matrix only and all jobs done?
    
    // if more than 2 matrices in q
    // multiply a seg
    // if first of 8 blocks: create aux space in the q
    // Multiply and store in aux space
    // if last: delete 1st 2 matrices
    // print details : Dijk pid ... mid

    while(1) {
        
    }
}

int main(int argc, char *argv[]) {
    int nP, nW;
    cin >> nP >> nW;
    int nMatrices;
    cin >> nMatrices;

    // SHM queue  https://2k8618.blogspot.com/2011/02/matrix-multiplication-using-shared.html
    // SHM job_created

    
    for(int i = 0; i < nP ; i++) {
        int fork_status = fork();
        if(fork_status == 0) {
            producer(i);
            exit(0);            
        }
    }
    
    for(int i = 0; i < nW; i++) {
        int fork_status = fork();
        if(fork_status == 0) {
            worker(i);
            exit(0);
        }
    }

    // check this : wait until 1 matrix and all jobs completed?
    while(wait(NULL) > 0);

    // Create nP, nW processes

    // Create (SHM) shared memory: shared among all
    // 1. queue: finite size (SIZE)
    // 2. job_created counter : no of matrices gen
    
    // Producer: 
    // 1. generate random job
    // 2. Wait for 0-3 s
    // 3. Try to insert in queue
    //      Wait until queue is full : 
    //      Print job details
    //      Increase job_counter

    // Worker:
    // 1. Wait for 0-3 s
    // 2. Retrieve 2 blocks of the first 2 matrices
    
    /*
    
    */

    return 0;
}


/*
https://www.geeksforgeeks.org/producer-consumer-problem-in-c/
Producer
do{

//produce an item

wait(empty);
wait(mutex);

//place in buffer

signal(mutex);
signal(full);

}while(true)


Consumer
do{

wait(full);
wait(mutex);

// remove item from buffer

signal(mutex);
signal(empty);

// consumes item

}while(true)
*/