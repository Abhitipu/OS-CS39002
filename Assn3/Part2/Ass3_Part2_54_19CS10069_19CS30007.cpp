#include <iostream>
#include <bitset>
#include <set>

#include <random>
#include <ctime>

#include <sys/types.h>
#include <sys/unistd.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <pthread.h>

using namespace std;

// pthread_mutex_t pmutex; // lock
pthread_mutexattr_t mattr;

const int SIZE = 8;
const int N = 4;
const int resultantMatrixProducer = -10;
set<int> matrixId;

// bitset function
void custom_set(uint8_t &bitset)
{
    bitset = 255;
    return;
}

size_t custom_find_first_one(uint8_t bitset)
{
    size_t i;
    uint8_t one = 1;
    for(i = 0; i < 8; ++i)
    {
        if( (one<<i) & bitset)
        {
            break;
        }
    }
    return i;
}

void custom_flip(uint8_t &bitset, int flip)
{
    if(flip <0 || flip > 7 ) 
        return;
    uint8_t one = 1;
    bitset = bitset ^ (one << flip);
    return ;
}


// generated by a producer and put into the job queue
struct job {
    int producerNumber;
    uint8_t status;
    int matrix[N][N];   // -9 <= matrix[i][j] <= 9
    int matrixId;       // rand(1...1e5)
    int resultIdx;      // where the resultant matrix is stored
};

void printJob(job* J) {
    cout<<"----------------------------Print Job----------------------------\n";
    cout<< "Producer Number : "<< J->producerNumber<<"\n";
    cout<<"Matrix Id : "<<J->matrixId<<"\n";
    cout<<"Status : "<<(uint)(J->status)<<"\n";
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++)
            cout << J->matrix[i][j] << " ";
        cout << '\n'; 
    }
}

void initJob(job* J, int _producerNumber = -1, int _matrixId = -1, int seed = 0, bool zero = false) {
    J->producerNumber = _producerNumber;
    J->matrixId = _matrixId;
    // srand(seed);
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++) {
            J->matrix[i][j] = (zero) ? 0 : (rand()%19 - 9);
        }
    }
    J->resultIdx = -1;
    // all ones , that means all of them needs to be completed       
    custom_set(J->status);
    return;
}

void copyJob(job* src, job* dest)
{
    if(src == NULL || dest == NULL ) {
        cout<<"Null pointer in copyJob\n";
        return ;
    }
    dest->producerNumber = src->producerNumber;
    dest->status = src->status;
    dest->matrixId = src->matrixId;
    dest->resultIdx = src->resultIdx;
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++) {
            dest->matrix[i][j] = src->matrix[i][j];
        }
    }
    return;
}

struct jobQueue
{
    job jobs[SIZE];
    int producerPtr, workerPtr; // tail, head
    int size; // job created
    int jobCreated;
    int totalJobs;
    int jobsDone;
    int curSegCounter; // counts how many segments have been merged to resultant matrix (0 to 8)
    pthread_mutex_t mutex_lock;  
};

int getrandId() {
    int ans = -1;
    do {
        ans = rand()%100000 + 1;
    } while(matrixId.count(ans));
    matrixId.insert(ans);
    return ans;
}

void jobQueueInit(int _totalJobs, jobQueue* Q) {
    // mutex lock
    Q->producerPtr = Q->workerPtr = 0;
    Q->jobCreated = 0;
    Q->size = 0;
    Q->jobsDone = 0;
    Q->totalJobs = _totalJobs;
    Q->curSegCounter = 0;
    // pthread_mutexattr_t mattr;
    pthread_mutexattr_init(&mattr);
    
    // pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ERRORCHECK_NP);
    if(pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)!=0){
    	cerr<<"Lock sharing Unsuccessful\n";
    	exit(1);
    }
    if(pthread_mutex_init(&(Q->mutex_lock), &mattr)!=0){
    	cerr<<"Error : mutex_lock init() failed\n";
    	exit(1);
    }
    // mutex lock
}

inline bool isJobFinished(jobQueue* Q) {
    cerr<<"Total jobs : "<<Q->totalJobs<<"\n";
    cerr<<"jobsDone : "<<Q->jobsDone<<"\n";
    return (Q->jobsDone >= Q->totalJobs - 1) && (Q->size == 1);
}

inline bool isJobCreated(jobQueue* Q) {
    cerr<<"Total jobs : "<<Q->totalJobs<<"\n";
    cerr<<"jobs Created : "<<Q->jobCreated<<"\n";
    return (Q->jobCreated >= Q->totalJobs);
}

void createJob(jobQueue* Q, job* newJob, int _producerNumber, int seed = 0, bool zero = false) {

    // Keep at least one empty space in queue to avoid deadlock
    while(Q->size + 1 >= SIZE){
        cerr<<"I am Alive (Producer createjob)\n";
        return;
    }

    if(pthread_mutex_lock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Lock Error\n";
        exit(1);
    }

    // check if more jobs are to be created
    if(isJobCreated(Q)) {
        if(pthread_mutex_unlock(&(Q->mutex_lock))!=0) {
            cerr<<"Mutex Unlock Error\n";
            exit(1);
        }
        return;
    }

    cerr<<"Cur Size : "<<Q->size<<endl;
    
    // copy job
    copyJob(newJob, &(Q->jobs[Q->producerPtr]));
    // Q->jobs[Q->producerPtr] = *newJob;
    
    // increment producerPtr, jobCreated and queue size
    Q->producerPtr = (Q->producerPtr + 1)%SIZE;
    (Q->jobCreated)++;
    (Q->size)++;
    
    // print details
    cout << newJob->producerNumber << "(producer) successfully created job with matrixid " << newJob->matrixId <<  "\n";
    cout << "Current process id is: " << getpid() << '\n';
    printJob(newJob);
    
    if(pthread_mutex_unlock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Unlock Error\n";
        exit(1);
    }

    return;
}

void completeJob(jobQueue* Q) {
    cout<<"Cur Size : "<<Q->size<<endl;

    // Q->size >= 2 or not all blocks are accessed and jobs still not finished

    // when to wait
    // 1)Q->size is 0 
    // 2)Q->size is 1 but all jobs not done
    // 3)Q->size > 1 but all accesses are made
    
    while((Q->size == 0) || ( Q->size > 1 && Q->jobs[Q->workerPtr].status == 0) || (Q->size == 1 && !(isJobFinished(Q)))){
        cerr<<"I am Alive (Worker completejob)\n";
        return;
    }
    
    // <-> wait 
    if(pthread_mutex_lock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Lock Error\n";
        exit(1);
    }
    
    // if it is finished
    if(isJobFinished(Q)) {
        if(pthread_mutex_unlock(&(Q->mutex_lock))!=0)
        {
            cerr<<"Mutex Unlock Error\n";
            exit(1);
        }
        return;
    }

    int workerPtr = Q->workerPtr;
    int producerPtr = Q->producerPtr;
    job &curJob = Q->jobs[workerPtr];
    job &nextJob = Q->jobs[(workerPtr + 1)%SIZE];
    
    
    if(curJob.resultIdx == -1) {
        // the first operation on the two matrices

        curJob.resultIdx = nextJob.resultIdx = producerPtr;
        initJob(&(Q->jobs[producerPtr]), resultantMatrixProducer, getrandId(), 0, true); 
        Q->producerPtr = (Q->producerPtr + 1)%SIZE;
        // C S
        // (Q->jobsDone)++;
        (Q->size)++;
    }
    
    size_t firstOn = custom_find_first_one(curJob.status);
    
    custom_flip(curJob.status, firstOn);
    custom_flip(nextJob.status, firstOn);

    
    if(pthread_mutex_unlock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Unlock Error\n";
        exit(1);
    }

    int resIdx = curJob.resultIdx;
    job &resJob = Q->jobs[resIdx];

    if(pthread_mutex_unlock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Unlock Error\n";
        exit(1);
    }


    cout << firstOn << '\n';
    if(firstOn == SIZE)
    {
        cout<<"All jobs are occupied\n";
        return;
    }
    ///
    // Compute D (i, j, k) = A(i, k) * B(k, j)

    int i = firstOn & 1, j = (firstOn >> 1)&1 , k = (firstOn>>2) & 1;
    int row1 = (N / 2)*i + (N / 2);
    int col2 = (N / 2)*j + (N / 2);
    int col1 = (N / 2)*k + (N / 2);
    
    int temp[N / 2][N / 2]; 
    for(int row = (N / 2)*i; row < row1; row++) {
        for(int col = (N / 2)*j; col < col2; col++) {
            temp[row - (N / 2)*i][col - (N / 2)*j] = 0;
            for(int cur = (N / 2)*k; cur < col1; cur++) {
                temp[row - (N / 2)*i][col - (N / 2)*j] += curJob.matrix[row][cur] * nextJob.matrix[cur][col];  
            }
        }
    }

    if(pthread_mutex_lock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Lock Error\n";
        exit(1);
    }
    
    cout<<"i,j,k "<<i<<", "<<j<<", "<<k<<endl;

    for(int row = (N / 2)*i; row < row1; row++) {
        for(int col = (N / 2)*j; col < col2; col++) {
            resJob.matrix[row][col] += temp[row - (N / 2)*i][col - (N / 2)*j];
            cout << resJob.matrix[row][col] << " ";
            // cout<<resJob.matrix[row][col]<<"\n";
        }
        cout<<"\n";
    }

    Q->curSegCounter++;
    cout<<"**************************first ON " << firstOn<<endl;

    if(Q->curSegCounter == SIZE) {
        // all done
        Q->curSegCounter = 0;
        Q->size -= 2;
        (Q->jobsDone)++;
        cout<<"Job Done worked id :"<<Q->workerPtr<< ", worker 2: "<< Q->workerPtr + 1 << "\n";
        printJob(&Q->jobs[resIdx]);
        // initJob(&Q->jobs[workerPtr]);
        // initJob(&Q->jobs[(workerPtr+1)%SIZE]);
        Q->workerPtr = (Q->workerPtr + 2)%SIZE;
    }

    if(pthread_mutex_unlock(&(Q->mutex_lock))!=0)
    {
        cerr<<"Mutex Unlock Error\n";
        exit(1);
    }
    return;
}

void producer(int producerId, jobQueue *Q) {
    srand(time(NULL) + producerId);
    while(!isJobCreated(Q)) {
        // 1. init random job
        job* newJob = new job;
        cerr<<"I am Alive (Producer)\n";
        initJob(newJob, producerId, getrandId(), time(NULL));

        // 2. Wait for a random time b/w 0-3 seconds
        int waitTime = rand()%4;
        sleep(waitTime);
        
        // 3. Try to insert into the job queue
        createJob(Q, newJob, producerId, producerId);
    }
    return;
}

void worker(int workerId, jobQueue *Q) {
    srand(time(NULL) + workerId);
    while(!isJobFinished(Q)) {
        cerr<<"I am Alive (Worker)\n";
        // 1. wait for 0-3 seconds
        int waitTime = rand()%4;
        sleep(waitTime);

        // 2. Retrive first 2 blocks and multiply the reqd part
        completeJob(Q);
    }
    return ;
}

int main(int argc, char *argv[]) {
    // Create nP, nW processes
    int nP, nW;
    nP = 5, nW = 10;
    // cin >> nP >> nW;
    int nMatrices;
    nMatrices = 4;
    // cin >> nMatrices;

    // Create (SHM) shared memory: shared among all
    // 1. queue: finite size (SIZE)
    // 2. job_created counter : no of matrices gen

    key_t shmkey = 154;
    int shmid1 = shmget(shmkey,sizeof(jobQueue),0666|IPC_CREAT);
    jobQueue *sharedJobQ;
    sharedJobQ = (jobQueue*) shmat(shmid1, NULL, 0);
    // pmutex = (jobQueue*) shmat(shmid1, NULL, 0);
    
    jobQueueInit(nMatrices, sharedJobQ);
    // shared
    for(int i = 0; i < nP ; i++) {
        int fork_status = fork();
        if(fork_status == 0) {
            cout<< "Producer "<<i<<" created\n";
            producer(i, sharedJobQ);
            cout<< "Producer "<<i<<" exited\n";
            shmdt((void *)sharedJobQ);
            exit(0);            
        }
    }
    
    for(int i = 0; i < nW; i++) {
        int fork_status = fork();
        if(fork_status == 0) {
            cout<< "Worker "<<i<<" created\n";
            worker(i, sharedJobQ);
            cout<< "Worker "<<i<<" exited\n";
            shmdt((void *)sharedJobQ);
            exit(0);
        }
    }
    // check this : wait until 1 matrix and all jobs completed?
    while(wait(NULL) > 0);
 
    pthread_mutex_destroy(&(sharedJobQ->mutex_lock));
    pthread_mutexattr_destroy(&mattr);

    shmdt((void *)sharedJobQ);
    shmctl(shmid1, IPC_RMID, NULL);
    return 0;
}
